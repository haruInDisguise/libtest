#ifndef _TEST_H_
#define _TEST_H_

/// # ```test``` - yet another unit testing framework
///
/// This library implements a small [stb style](https://github.com/nothings/stb) unit testing
/// framework that tries to be small and easy to use and/or hack.
///
/// ## Features
///
/// - Lightweight and easy to use (hopefully)
/// - [xUnit](https://en.wikipedia.org/wiki/XUnit) inspired framework
/// - Automatic test registration

#define _GNU_SOURCE /* fileno() */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#ifdef TEST_DEBUG
    #if defined(__has_builtin) && __has_builtin(__builtin_debugtrap)
        #define TEST_BUILTIN_TRAP __builtin_debugtrap()
    #else
        #define TEST_BUILTIN_TRAP __asm__("int3")
    #endif

    #define test_intern_assert(condition)                                                    \
        do {                                                                                 \
            if (!(condition)) {                                                              \
                printf(                                                                      \
                    "Assertion failed: [%s %s():%d] \"%s\"\n", __FILE__, __func__, __LINE__, \
                    #condition                                                               \
                );                                                                           \
                TEST_BUILTIN_TRAP;                                                           \
            }                                                                                \
        } while (0)
#else
    #define test_intern_assert(condition)
#endif // TEST_DEBUG

#if defined(__clang__) || defined(__GNUC__)
    #define _TEST_CASE_SECTION __attribute__((used, section("test_case_section")))
    #define _TEST_SUIT_SECTION __attribute__((used, section("test_suit_section")))
    #define TEST_UNUSED        __attribute__((unused))
#else
    #error "Compiler not supported :^("
#endif

#ifndef TEST_VALUE_BUFFER_SIZE
    #define TEST_VALUE_BUFFER_SIZE 32
#endif

/// The maximum length of any single message generated by this library
#ifndef TEST_LOG_BUFFER_SIZE
    #define TEST_LOG_BUFFER_SIZE 1024
#endif

/// Macro for defining a new suit. Note that you have to define at least one
/// suit
#define SUIT(suit_name, setup, teardown)                        \
    static const test_intern_SuitData test_suit_##suit_name = { \
        .name = #suit_name,                                     \
        .teardown_function = teardown,                          \
        .setup_function = setup,                                \
    };                                                          \
    _TEST_SUIT_SECTION                                          \
    const test_intern_SuitData *test_suit_ptr_##suit_name = &test_suit_##suit_name

/// Macro for creating a new test case.
/// @param suit_name The name of the suit this test case should be added to.
/// @param test_name The name of this test case
#define TEST(suit_name_, test_name)                                           \
    static void test_##suit_name_##_##test_name(test_intern_TestInfo *_info); \
    static const test_intern_TestCase test_case_##test_name##_##suit_name = { \
        .name = #test_name,                                                   \
        .line = __LINE__,                                                     \
        .file_name = __FILE__,                                                \
        .suit_name = #suit_name_,                                             \
        .function = test_##suit_name_##_##test_name                           \
    };                                                                        \
    _TEST_CASE_SECTION                                                        \
    const test_intern_TestCase *test_case_ptr_##test_name##_##suit_name =     \
        &test_case_##test_name##_##suit_name;                                 \
    static void test_##suit_name_##_##test_name(TEST_UNUSED test_intern_TestInfo *_test_info)

#define TEST_MAIN                     \
    int main(int argc, char **argv) { \
        if (!test_init(argc, argv)) { \
            return 1;                 \
        }                             \
        test_run_all();               \
        test_exit();                  \
        return 0;                     \
    }

#define _TEST_CMP(type, lhs, rhs, macro, CMP_FUNC)             \
    do {                                                       \
        if (!CMP_FUNC(lhs, rhs)) {                             \
            _test_info->assertion_info.line = __LINE__;        \
            _test_info->assertion_info.macro_name = #macro;    \
            _test_info->assertion_info.macro_value_lhs = #lhs; \
            _test_info->assertion_info.macro_value_rhs = #rhs; \
            _test_info->result = test_intern_ResultFailed;     \
            test_intern_log_assertion_failed(_test_info);      \
        }                                                      \
    } while (0)

// clang-format off
#define _TEST_CMP_EQ(lhs, rhs) ((lhs) == (rhs))
#define _TEST_CMP_NE(lhs, rhs) ((lhs) != (rhs))

#define _TEST_CMP_GT(lhs, rhs) ((lhs) > (rhs))
#define _TEST_CMP_LT(lhs, rhs) ((lhs) < (rhs))
#define _TEST_CMP_GE(lhs, rhs) ((lhs) >= (rhs))
#define _TEST_CMP_LE(lhs, rhs) ((lhs) <= (rhs))

#define _TEST_CMP_STR_EQ(lhs, rhs) (strcmp(lhs, rhs) == 0)
#define _TEST_CMP_STR_NE(lhs, rhs) (strcmp(lhs, rhs) != 0)

#define _TEST_CMP_MEM_EQ(lhs, rhs, size) (memcmp(lhs, rhs, size) == 0)
#define _TEST_CMP_MEM_NE(lhs, rhs, size) (memcmp(lhs, rhs, size) != 0)

// Assert Macros
#define test_assert(lhs)                 _TEST_CMP(test_TypeCustom, lhs, 1, assert, _TEST_CMP_EQ)
#define test_assert_eq(lhs, rhs)         _TEST_CMP(test_TypeCustom, lhs, rhs, assert_eq, _TEST_CMP_EQ)
#define test_assert_ne(lhs, rhs)         _TEST_CMP(test_TypeCustom, lhs, rhs, assert_ne, _TEST_CMP_NE)

#define test_assert_string_eq(lhs, rhs)         _TEST_CMP(test_TypeCString, lhs, rhs, assert_str_eq, _TEST_CMP_STR_EQ)
#define test_assert_string_ne(lhs, rhs)         _TEST_CMP(test_TypeCString, lhs, rhs, assert_str_ne,_TEST_CMP_STR_NE)

#define test_assert_memory_eq(lhs, rhs, size)   _TEST_CMP(test_TypeMemory, lhs, rhs, assert_str_eq, _TEST_CMP_MEM_EQ)
#define test_assert_memory_ne(lhs, rhs, size)   _TEST_CMP(test_TypeMemory, lhs, rhs, assert_str_ne,_TEST_CMP_MEM_NE)
// clang-format on

#define test_intern_ResultCount 4
typedef enum {
    test_intern_ResultOk,
    test_intern_ResultPartiallyOk,
    test_intern_ResultSkipped,
    test_intern_ResultFailed,
} test_intern_Result;

typedef struct {
    struct {
        uint32_t line;
        char *macro_value_lhs;
        char *macro_value_rhs;
        char *macro_name;
    } assertion_info;

    bool is_verbose;
    test_intern_Result result;
} test_intern_TestInfo;

typedef void (*test_TestFunction)(test_intern_TestInfo *_test_info);
typedef void (*test_SetupFunction)(void);
typedef void (*test_TeardownFunction)(void);

typedef struct {
    uint32_t line;
    char *name;
    char *suit_name;
    char *file_name;
    test_TestFunction function;
} test_intern_TestCase;

typedef struct {
    char *name;
    test_SetupFunction setup_function;
    test_TeardownFunction teardown_function;
} test_intern_SuitData;

extern bool test_init(int argc, char **argv);
extern void test_exit(void);

extern void test_intern_log_assertion_failed(const test_intern_TestInfo *info);

/// Reset statistics (total time, tests executed etc.)
extern void test_reset(void);
extern void test_report(void);

extern bool
test_register_suit(char *name, test_SetupFunction setup_func, test_TeardownFunction teardown_func);
extern bool test_register_case(char *suit_name, char *test_name, test_TestFunction func);

extern bool test_run_suit(const char *name);
extern bool test_run_case(const char *suit_name, const char *case_name);
extern void test_run_all(void);

extern const char *test_option_get_output_path(void);
extern const char *test_option_get_filter(void);

#endif // _TEST_H_

#ifdef TEST_IMPLEMENTATION
#include <errno.h>  /* errno */
#include <malloc.h> /* malloc, calloc */
#include <stdarg.h>
#include <stdbool.h>
#include <stdlib.h> /* abort, exit */
#include <string.h> /* sterror, strcmp, memset */
#include <unistd.h> /* isatty */

#if defined(__clang__) || defined(__GNUC__)
// see:
// https://stackoverflow.com/questions/16552710/how-do-you-get-the-start-and-end-addresses-of-a-custom-elf-section
extern test_intern_TestCase *__start_test_case_section;
extern test_intern_TestCase *__stop_test_case_section;
#define _TEST_START_CASE_SECTION (&__start_test_case_section)
#define _TEST_STOP_CASE_SECTION (&__stop_test_case_section)

extern test_intern_SuitData *__start_test_suit_section;
extern test_intern_SuitData *__stop_test_suit_section;
#define _TEST_START_SUIT_SECTION (&__start_test_suit_section)
#define _TEST_STOP_SUIT_SECTION (&__stop_test_suit_section)

#else
    #error "Compiler not supported :^("
#endif

#define COLOR_RESET   "\033[0m"
#define COLOR_BLACK   "\033[30m"
#define COLOR_RED     "\033[31m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_BLUE    "\033[34m"
#define COLOR_MAGENTA "\033[35m"
#define COLOR_CYAN    "\033[36m"
#define COLOR_WHITE   "\033[37m"
#define COLOR_DEFAULT "\033[38m"

/// Used internally. Represents 'state' of the testing process.
#define test_intern_StatusCount 5
typedef enum {
    test_intern_StatusEmpty,
    test_intern_StatusResult,
    test_intern_StatusRunning,
    test_intern_StatusReport,
    test_intern_StatusContinued,
} test_intern_Status;

typedef struct {
    uint32_t test_count;
    test_intern_TestCase const **test_list;
    const test_intern_SuitData *suit_data;
} test_intern_Suit;

static struct {
    uint32_t total_suits;
    uint32_t total_tests;
    test_intern_Suit *suit_list;
} test_register = { 0 };

static struct {
    uint32_t tests_successful;
    uint32_t tests_failed;
    uint32_t tests_partially;
    uint32_t tests_skipped;
    uint32_t suits_failed;
    uint32_t suits_skipped;
} test_runner = { 0 };

static struct {
    uint32_t length;
    uint32_t offset;
    char *buffer;
} log_data = { 0 };

static struct {
    bool colored;
    bool verbose;
    bool print_list;

    // Argument flag values as they are being read from the commandline
    // before any parsing takes place
    struct {
        char *colored_value;
        char *output_value;
        char *filter_value;
    } raw;

    FILE *output_stream;

    char **target_suits;
    char **target_cases;
} options = { 0 };

static inline void *test_realloc(void *base, uintptr_t size) {
    void *result = realloc(base, size);
    if (result == NULL) {
        perror("test: ");
        abort();
    }

    return result;
}

static inline void *test_calloc(uint64_t nmem, uint64_t smem) {
    void *result = calloc(nmem, smem);
    if (result == NULL) {
        perror("test: ");
        abort();
    }

    return result;
}

static inline void test_log_init(void) {
    log_data.offset = 0;
    log_data.length = TEST_LOG_BUFFER_SIZE;
    log_data.buffer = test_calloc(1, TEST_LOG_BUFFER_SIZE * sizeof(*log_data.buffer));
}

static inline void test_log_free(void) { free(log_data.buffer); }

static inline void test_log_clear(void) {
    log_data.offset = 0;
    // memset(log_data.buffer, 0, log_data.length * sizeof (*log_data.buffer));
}

static void test_log_write(const char *format, va_list *args) {
    test_intern_assert(args != NULL);
    test_intern_assert(format != NULL);
    test_intern_assert(log_data.length - log_data.offset > 0);

    vsnprintf(log_data.buffer + log_data.offset, log_data.length - log_data.offset, format, *args);
    fprintf(options.output_stream, "%s", log_data.buffer);
    test_log_clear();
}

__attribute__((format(printf, 2, 3))) static void
test_log_write_with_status(const test_intern_Status status, const char *format, ...) {
    test_intern_assert(format != NULL);
    test_intern_assert(status < test_intern_StatusCount);

    static const char *status_string[] = {
        [test_intern_StatusResult] = "RESULT ",
        [test_intern_StatusRunning] = "RUNNING",
        [test_intern_StatusReport] = "REPORT ",
        [test_intern_StatusContinued] = "-------",
    };

    if (status == test_intern_StatusEmpty) {
        log_data.offset = 0;
    } else {
        log_data.offset =
            snprintf(log_data.buffer, log_data.length, "[ %s ] ", status_string[status]);
    }

    va_list args;
    va_start(args, format);

    test_log_write(format, &args);

    va_end(args);
}

/* Test runner */
static void test_runner_report(void) {
    uint32_t tests_failed_percent =
        (test_runner.tests_failed > 0)
            ? (test_runner.tests_failed * 100 / test_register.total_tests)
            : 0;
    uint32_t tests_skipped_percent =
        (test_runner.tests_skipped > 0)
            ? (test_runner.tests_skipped * 100 / test_register.total_tests)
            : 0;

    uint32_t tests_successful_percent =
        (test_runner.tests_successful) > 0
            ? (test_runner.tests_successful * 100 / test_register.total_tests)
            : 0;
    uint32_t tests_partial_percent =
        (test_runner.tests_partially > 0)
            ? (test_runner.tests_partially * 100 / test_register.total_tests)
            : 0;

    test_log_write_with_status(
        test_intern_StatusReport, "=== Results for %d tests ===\n", test_register.total_tests
    );
    test_log_write_with_status(
        test_intern_StatusContinued, "Successful: %u - %3u%%\n", test_runner.tests_successful,
        tests_successful_percent
    );
    test_log_write_with_status(
        test_intern_StatusContinued, "Failed    : %u - %3u%%\n", test_runner.tests_failed,
        tests_failed_percent
    );
    test_log_write_with_status(
        test_intern_StatusContinued, "Partially : %u - %3u%%\n", test_runner.tests_partially,
        tests_partial_percent
    );
    test_log_write_with_status(
        test_intern_StatusContinued, "Skipped   : %u - %3u%%\n", test_runner.tests_skipped,
        tests_skipped_percent
    );
}

static void
test_runner_run_test(const test_intern_TestCase *test, const test_intern_SuitData *suit) {
    test_intern_assert(test != NULL);
    test_intern_assert(suit != NULL);

    test_intern_TestInfo info = { .result = test_intern_ResultOk };

    test_log_write_with_status(
        test_intern_StatusRunning, "%s => %s:%s\n", test->file_name, suit->name, test->name
    );

    if (suit->setup_function != NULL) {
        suit->setup_function();
    }

    test->function(&info);

    test_intern_assert(info.result < test_intern_ResultCount);

    if (suit->teardown_function != NULL) {
        suit->teardown_function();
    }

    switch (info.result) {
    case test_intern_ResultOk:
        test_runner.tests_successful++;
        break;
    case test_intern_ResultPartiallyOk:
        test_runner.tests_partially++;
        break;
    case test_intern_ResultSkipped:
        test_runner.tests_skipped++;
        break;
    case test_intern_ResultFailed:
        test_runner.tests_failed++;
        break;
    }

    static const char *result_strings_colored[] = {
        [test_intern_ResultOk] = COLOR_GREEN "OK" COLOR_RESET,
        [test_intern_ResultPartiallyOk] = COLOR_YELLOW "PARTIALLY OK" COLOR_RESET,
        [test_intern_ResultSkipped] = COLOR_CYAN "SKIPPED" COLOR_RESET,
        [test_intern_ResultFailed] = COLOR_RED "FAILED" COLOR_RESET,
    };
    static const char *result_strings_blank[] = {
        [test_intern_ResultOk] = "OK",
        [test_intern_ResultPartiallyOk] = "PARTIALLY OK",
        [test_intern_ResultSkipped] = "SKIPPED",
        [test_intern_ResultFailed] = "FAILED",
    };

    const char **result_strings = options.colored ? result_strings_colored : result_strings_blank;
    test_log_write_with_status(test_intern_StatusResult, "%s\n", result_strings[info.result]);
}

static void test_runner_run_suit(const test_intern_Suit *suit_data) {
    test_intern_assert(suit_data != NULL);

    for (uint32_t i = 0; i < suit_data->test_count; i++) {
        test_runner_run_test(suit_data->test_list[i], suit_data->suit_data);
    }
}

static void test_runner_reset(void) { memset(&test_runner, 0, sizeof(test_runner)); }

static test_intern_Suit *test_suit_find_by_name(const char *name) {
    test_intern_assert(name != NULL);

    for (uint32_t i = 0; i < test_register.total_suits; i++) {
        test_intern_Suit *suit_data = &test_register.suit_list[i];

        if (strcmp(suit_data->suit_data->name, name) == 0) {
            return suit_data;
        }
    }

    return NULL;
}

void test_intern_log_assertion_failed(const test_intern_TestInfo *test_info) {
    test_intern_assert(test_info != NULL);

    const char *value_one_macro = test_info->assertion_info.macro_value_lhs;
    const char *value_two_macro = test_info->assertion_info.macro_value_rhs;
    const char *macro_name = test_info->assertion_info.macro_name;
    const uint32_t line = test_info->assertion_info.line;

    const char *message_prefix =
        test_info->result == test_intern_ResultFailed ? "assertion failed" : "check failed";

    test_log_write_with_status(
        test_intern_StatusContinued, "%s @ %d: %s(%s, %s)\n", message_prefix, line, macro_name,
        value_one_macro, value_two_macro
    );
}

// TODO: Implement manual suit registration
bool test_register_suit(
    char *name, test_SetupFunction setup_func, test_TeardownFunction teardown_func
) {
    (void)name;
    (void)setup_func;
    (void)teardown_func;

    return false;
}

// TODO: Implement manual test registration
bool test_register_case(char *suit_name, char *test_name, test_TestFunction func) {
    (void)suit_name;
    (void)test_name;
    (void)func;

    return false;
}

bool test_run_case(const char *suit_name, const char *case_name) {
    test_intern_assert(case_name != NULL);
    test_intern_assert(suit_name != NULL);

    const test_intern_TestCase *test_case = NULL;
    const test_intern_Suit *suit_data = test_suit_find_by_name(suit_name);

    if (suit_data == NULL) {
        fprintf(options.output_stream, "test_run_case(): Unable to find suit\n");
        return false;
    }

    for (uint32_t i = 0; i < suit_data->test_count; i++) {
        test_case = suit_data->test_list[i];
        if (strcmp(case_name, test_case->name)) {
            test_runner_run_test(test_case, suit_data->suit_data);

            return true;
        }
    }

    fprintf(
        options.output_stream, "test_run_case(): Unable to find test \"%s\" in suit \"%s\"",
        case_name, suit_name
    );
    return false;
}

bool test_run_suit(const char *name) {
    test_intern_assert(name != NULL);
    test_intern_Suit *suit_data = test_suit_find_by_name(name);

    if (suit_data == NULL) {
        return false;
    }

    test_runner_run_suit(suit_data);
    return true;
}

void test_run_all(void) {
    for (uint32_t i = 0; i < test_register.total_suits; i++) {
        test_runner_run_suit(&test_register.suit_list[i]);
    }

    test_runner_report();
}

// Algorithm copied from:
// http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html
TEST_UNUSED static bool test_match_wildcard(char *const match, char *const pattern) {
    char *pattern_seek_ptr = pattern;
    char *match_seek_ptr = match;
    char *star_match_index = NULL;
    char *star_pattern_index = NULL;

    // We always match atleast one character. Globs '*' is equvalent to regex '+' operator
    while (*pattern) {
        // '?' simply matches exactly one character
        if (*match_seek_ptr == '?' || *pattern == *match_seek_ptr) {
            pattern_seek_ptr++;
            match_seek_ptr++;
            continue;
        }

        // '*' pattern start
        if (*pattern_seek_ptr == '*') {
            // remember old position, in case of a mismatch
            star_match_index = match_seek_ptr;
            star_pattern_index = pattern_seek_ptr;
            // just increment the match ptr because the pattern might only match one character
            match_seek_ptr++;
            continue;
        }

        // Nothing matches
        if (star_pattern_index) {
            // '*' matched one character
            match_seek_ptr = star_match_index + 1;
            pattern_seek_ptr = star_pattern_index + 1;
            star_match_index++;
            continue;
        }

        return false;
    }

    while (*pattern_seek_ptr == '*') {
        pattern_seek_ptr++;
    }

    return true;
}

static bool test_parse_arguments(int argc, char **argv) {
    test_intern_assert(argv != NULL);
    test_intern_assert(argc > 0);

    memset(&options, 0, sizeof(options));

    for (int32_t i = 1; i < argc; i++) {
        char **second_argument_target = NULL;
        bool is_valid_argument = false;

        if (strcmp(argv[i], "--verbose") == 0 || strcmp(argv[i], "-v") == 0) {
            is_valid_argument = true;
            options.verbose = true;
        } else if (strcmp(argv[i], "--list") == 0) {
            is_valid_argument = true;
            options.print_list = true;
        } else if (strcmp(argv[i], "--colored") == 0) {
            is_valid_argument = true;
            second_argument_target = &options.raw.colored_value;
        } else if (strcmp(argv[i], "--output") == 0) {
            is_valid_argument = true;
            second_argument_target = &options.raw.output_value;
        } else if (strcmp(argv[i], "--filter") == 0) {
            is_valid_argument = true;
            second_argument_target = &options.raw.filter_value;
        }

        if (is_valid_argument == false) {
            fprintf(stderr, "[test]: Unrecognized flag: %s\n", argv[i]);
            return false;
        }

        if (second_argument_target != NULL) {
            if (i + 1 >= argc) {
                fprintf(stderr, "[test]: Missing option for flag: %s\n", argv[i]);
                return false;
            }

            *second_argument_target = argv[i + 1];
            i += 1;
        }
    }

    return true;
}

static bool test_parse_options(void) {
    char *option = options.raw.output_value;
    char *flag = "--output";
    if (option != NULL) {
        if (access(option, F_OK) == 0) {
            fprintf(stderr, "[test]: Output file already exists: %s\n", option);
            return false;
        }

        FILE *output_file = fopen(option, "w");
        if (output_file == NULL) {
            fprintf(
                stderr, "[test]: Failed to open output file: %s: %s\n", option, strerror(errno)
            );
            return false;
        }

        options.output_stream = output_file;
    } else {
        options.output_stream = stdout;
    }

    flag = "--colored";
    if (options.raw.colored_value == NULL) {
        options.raw.colored_value = "auto";
    }
    option = options.raw.colored_value;

    if (strcmp(option, "auto") == 0) {
        options.colored = isatty(fileno(options.output_stream)) ? true : false;
    } else if (strcmp(option, "always") == 0) {
        options.colored = true;
    } else if (strcmp(option, "never") == 0) {
        options.colored = false;
    } else {
        goto invalid_option;
    }

    option = options.raw.filter_value;
    flag = "--filter";
    if (option == NULL) {
        /* TODO */
    }

    option = options.raw.colored_value;
    flag = "--list";
    if (options.print_list == true) {
        /* TODO */
    }

    return true;
invalid_option:
    fprintf(stderr, "[test]: Invalid option for flag '%s': %s\n", flag, option);
    return false;
}

bool test_init(int argc, char **argv) {
    if (test_parse_arguments(argc, argv) == false) {
        return false;
    }

    if (test_parse_options() == false) {
        return false;
    }

    test_log_init();
    test_runner_reset();

    memset(&test_register, 0, sizeof(test_register));

    // Register all suits
    uintptr_t suit_count = _TEST_STOP_SUIT_SECTION - _TEST_START_SUIT_SECTION;
    test_intern_assert(suit_count > 0);
    test_intern_assert(suit_count < (uint32_t)(-1));

    test_register.total_suits = (uint32_t)suit_count;
    test_register.suit_list = test_calloc(sizeof(test_intern_Suit [suit_count]), 1);

    for(uint32_t suit_index = 0; suit_index < suit_count; suit_index ++) {
        test_register.suit_list[suit_index].suit_data = _TEST_START_SUIT_SECTION[suit_index];
    }

    test_intern_Suit *last_suit = NULL;
    test_intern_Suit *current_suit = NULL;

    // Register all cases

    // NOTE: Iteration through cases in the facion shown in the subsequent line causes a runtime error in address sanitizer:
    // error: load of address 0x64f40a6afa70 with insufficient space for an object of type 'struct test_intern_TestCase *'
    // The program proceeds to execute as expected. Figure out what is wrong...

    /*uintptr_t case_count = _TEST_STOP_CASE_SECTION - _TEST_START_CASE_SECTION;*/
    /*test_intern_assert(case_count > 0);*/
    /*test_intern_assert(case_count < (uint32_t)(-1));*/

    /*for (uint32_t case_index = 0; case_index < case_count; case_index ++) {*/
        /*const test_intern_TestCase *test_case = _TEST_START_CASE_SECTION[case_index];*/

    for(test_intern_TestCase **test_case_iter = _TEST_START_CASE_SECTION; test_case_iter < _TEST_STOP_CASE_SECTION; test_case_iter ++) {
        const test_intern_TestCase *test_case = *test_case_iter;

        // It is (probably) likely that adjacent tests belong to the same suit
        if ((current_suit == NULL) ||
            (last_suit != NULL && strcmp(last_suit->suit_data->name, test_case->suit_name) != 0)) {
            current_suit = test_suit_find_by_name(test_case->suit_name);
        }

        if (current_suit == NULL) {
            fprintf(
                options.output_stream, "Unable to find suit \"%s\" for test case \"%s\"\n",
                test_case->suit_name, test_case->name
            );
            return false;
        }

        current_suit->test_list = test_realloc(
            current_suit->test_list, sizeof(test_intern_TestCase * [current_suit->test_count + 1])
        );

        current_suit->test_list[current_suit->test_count] = test_case;
        current_suit->test_count++;
        test_register.total_tests++;
        last_suit = current_suit;
    }

    return true;
}

void test_exit(void) {
    if (options.output_stream != NULL && options.raw.output_value != NULL) {
        fclose(options.output_stream);
    }

    test_log_free();

    for (uint32_t i = 0; i < test_register.total_suits; i++) {
        free(test_register.suit_list[i].test_list);
    }

    free(test_register.suit_list);
}

#endif
